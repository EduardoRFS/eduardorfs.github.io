<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>A tale about computers</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="A tale about computers">
<meta property="og:url" content="https://eduardorfs.github.io/index.html">
<meta property="og:site_name" content="A tale about computers">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="A tale about computers">
  
    <link rel="alternate" href="/atom.xml" title="A tale about computers" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <!-- <a id="main-nav-toggle" class="nav-icon"></a> -->
        
        <a class="main-nav-link" href="/"
          >Home</a
        >
        
        <a class="main-nav-link" href="/archives"
          >Archives</a
        >
        
      </nav>
      <nav id="sub-nav">
        
        <a
          id="nav-rss-link"
          class="nav-icon"
          href="/atom.xml"
          title="RSS Feed"
        ></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://eduardorfs.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-weakening_on_linear_f" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/08/weakening_on_linear_f/" class="article-date">
  <time datetime="2023-01-08T17:47:30.000Z" itemprop="datePublished">2023-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/08/weakening_on_linear_f/">A tale of sum types on Linear F</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>The <a href="https://github.com/EduardoRFS/linear-f/" target="_blank" rel="noopener">Linear F</a> is a system similar to <a href="https://www.cis.upenn.edu/~stevez/papers/MZZ10.pdf" target="_blank" rel="noopener">System F◦</a>, but where the traditional type kind was removed, so it is a pure linear lambda calculus with first-class polymorphism.</p>
<h2 id="TLDR"><a href="#TLDR" class="headerlink" title="TLDR"></a>TLDR</h2><p>To encode sum types, weakening is required. By carrying the garbage around in a monad you can easily model do weakening on Linear F. As such you can encode sum types on Linear F. Proof <a href="https://github.com/EduardoRFS/linear-f/blob/main/examples/weak.linf#L34" target="_blank" rel="noopener">weak.linf</a></p>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>I’ve been playing with linear type systems for a while, currently I hold the opinion that some form of linear calculus is probably the right solution for a modern functional programming language.</p>
<p>As such I’ve been trying to show that you can do everything in a pure linear calculus. By doing {church,scott}-encoding of every interesting primitive present in real languages, sadly many of the traditional encodings rely on weakening, which is not directly available on a linear calculus due to that, the traditional wisdom is that sum types are not possible in a pure linear calculus.</p>
<h2 id="Explicit-Weakening"><a href="#Explicit-Weakening" class="headerlink" title="Explicit Weakening"></a>Explicit Weakening</h2><p>My hypothesis is that weakening can always be explicitly encoded in a linear system by carrying everything discard explicitly as a parameter.</p>
<p>The main idea is that any function that relies on weakening can return all the discarded elements together with its output as a multiplicative products aka a pair.</p>
<h3 id="Naive-Weakening-Encoding"><a href="#Naive-Weakening-Encoding" class="headerlink" title="Naive Weakening Encoding"></a>Naive Weakening Encoding</h3><p>The simplest encoding possible is to literally just return a pair, so to describe the affine term <code>x =&gt; y =&gt; x</code> would be written as <code>x =&gt; y =&gt; (x, y)</code>, the convention here is that the second element of the pair is just garbage and as such should be ignored.</p>
<h3 id="Nicer-Weakening-Encoding"><a href="#Nicer-Weakening-Encoding" class="headerlink" title="Nicer Weakening Encoding"></a>Nicer Weakening Encoding</h3><p>A type encoding is possible for the garbage in the presence of existential types, the garbage bag can have the type of <code>Garbage === ∃x. x</code>, which can be encoded in Linear F. This makes so that a function to <a href="https://github.com/EduardoRFS/linear-f/blob/main/examples/weak.linf#L10" target="_blank" rel="noopener">collect garbage</a> can be done.</p>
<h3 id="An-even-nicer-weakening-encoding"><a href="#An-even-nicer-weakening-encoding" class="headerlink" title="An even nicer weakening encoding"></a>An even nicer weakening encoding</h3><p>A nicer encoding can be done by making a monad for weakening, this makes so that handling garbage is implicit in the monadic context. <code>Weak A === Garbage -&gt; (A, Garbage)</code>, so any function doing weakening can have the type <code>A -&gt; Weak B</code>.</p>
<h3 id="The-perfect-weakening-encoding"><a href="#The-perfect-weakening-encoding" class="headerlink" title="The perfect weakening encoding"></a>The perfect weakening encoding</h3><p>While monadic weakening is nice enough to actually use it, an even better one would be an encoding based on algebraic effects, such that the function <code>weak : ∀A. A -[Weak]&gt; ()</code> can be used to explicit weaken anything, such a function wills simply pack it as <code>Garbage</code> and call the effect handler, which can then decide what to do with such piece of data.</p>
<p>This could be combined with first class support of the language as an implicit effect so that it behaves exactly like an affine system.</p>
<h2 id="Back-to-Sum-Types"><a href="#Back-to-Sum-Types" class="headerlink" title="Back to Sum Types"></a>Back to Sum Types</h2><p>Many of the traditional church encodings for data rely on weakening, such as booleans and sum types, ex : <code>true === x =&gt; y =&gt; x</code>. As such those encodings seems to not work in a purely linear setting, but they can be done in an affine setting.</p>
<p>And as shown above, weakening can be done on the Linear System F, which is contrary to some beliefs:</p>
<blockquote>
<p>[MZZ10] - we cannot encode linear sums in System F◦ as presented so far</p>
</blockquote>
<blockquote>
<p><a href="https://oleg.fi/gists/posts/2019-06-26-linear-church-encodings.html#encoding-of-with" target="_blank" rel="noopener">Church encoding of linear types</a> - Unfortunate, but known fact. So, we cannot (at least obviously) simulate A &amp; B using something else.</p>
</blockquote>
<h3 id="Linear-F-Either"><a href="#Linear-F-Either" class="headerlink" title="Linear F + Either"></a>Linear F + Either</h3><p>Either is the canonical sum type, if you can describe it you can describe any other sum type, so showing Either is enough to show all sum types.</p>
<p>Example for Either can be found at <a href="https://github.com/EduardoRFS/linear-f/blob/f95c751f04bf0097c9c7220bb5b9d686a381d1f7/examples/weak.linf#L34" target="_blank" rel="noopener">weak.linf</a>.</p>
<h3 id="Linear-F-Bool"><a href="#Linear-F-Bool" class="headerlink" title="Linear F + Bool"></a>Linear F + Bool</h3><p>But a simpler example that is easier to analyze are booleans,</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// let's assume the weakening monad</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Weak</span></span> A === Garbage -&gt; Pair A Garbage <span class="keyword">in</span></span><br><span class="line"><span class="keyword">let</span> weak : forall A. A -&gt; Weak Unit === _ <span class="keyword">in</span></span><br><span class="line"><span class="keyword">let</span> map : forall A B. Weak A -&gt; (A -&gt; B) -&gt; Weak B === _ <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// on booleans one of the arguments is always weakened</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Bool</span></span> === forall A. A -&gt; A -&gt; Weak A <span class="keyword">in</span></span><br><span class="line"><span class="keyword">let</span> <span class="literal">true</span> : Bool === fun (<span class="class"><span class="keyword">type</span> <span class="title">A</span></span>) x y -&gt;</span><br><span class="line">  map (<span class="class"><span class="keyword">type</span> <span class="title">Unit</span></span>) (<span class="class"><span class="keyword">type</span> <span class="title">A</span></span>)</span><br><span class="line">    <span class="comment">// weakens y</span></span><br><span class="line">    (weak (<span class="class"><span class="keyword">type</span> <span class="title">A</span></span>) y)</span><br><span class="line">    <span class="comment">// returns x</span></span><br><span class="line">    (fun unit -&gt; unit (<span class="class"><span class="keyword">type</span> <span class="title">A</span></span>) x) <span class="keyword">in</span></span><br><span class="line"><span class="keyword">let</span> <span class="literal">false</span> : Bool === fun (<span class="class"><span class="keyword">type</span> <span class="title">A</span></span>) x y -&gt;</span><br><span class="line">  map (<span class="class"><span class="keyword">type</span> <span class="title">Unit</span></span>) (<span class="class"><span class="keyword">type</span> <span class="title">A</span></span>)</span><br><span class="line">    <span class="comment">// weakens x</span></span><br><span class="line">    (weak (<span class="class"><span class="keyword">type</span> <span class="title">A</span></span>) x)</span><br><span class="line">    <span class="comment">// returns y</span></span><br><span class="line">    (fun unit -&gt; unit (<span class="class"><span class="keyword">type</span> <span class="title">A</span></span>) y) <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// examples</span></span><br><span class="line"><span class="comment">/* because variables cannot appear twice, closures cannot be used</span></span><br><span class="line"><span class="comment">    so the solution is to pass functions, aka CPSify the matching</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  A is the shared context between branches</span></span><br><span class="line"><span class="comment">  K is the return type of the matching */</span></span><br><span class="line"><span class="keyword">let</span> match_bool : forall A K. Bool -&gt; (A -&gt; K) -&gt; (A -&gt; K) -&gt; A -&gt; Weak K ===</span><br><span class="line">  fun (<span class="class"><span class="keyword">type</span> <span class="title">A</span></span>) (<span class="class"><span class="keyword">type</span> <span class="title">K</span></span>) b then_ else_ x -&gt;</span><br><span class="line">    b (<span class="class"><span class="keyword">type</span> <span class="title">K</span></span>) then_ else_ x <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// slightly more concrete example, assumes integers</span></span><br><span class="line"><span class="keyword">let</span> incr_if_true : Bool -&gt; Int -&gt; Weak Int ===</span><br><span class="line">  fun b x -&gt;</span><br><span class="line">    <span class="comment">/* because x cannot appear twice,</span></span><br><span class="line"><span class="comment">       we need to do the case on a function */</span></span><br><span class="line">    b (<span class="class"><span class="keyword">type</span> <span class="title">Int</span></span>)</span><br><span class="line">      (fun (x : Int) -&gt; x + <span class="number">1</span>)</span><br><span class="line">      (fun (x : Int) -&gt; x)</span><br><span class="line">      <span class="comment">// actually apply</span></span><br><span class="line">      x</span><br></pre></td></tr></table></figure>

<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://www.cis.upenn.edu/~stevez/papers/MZZ10.pdf" target="_blank" rel="noopener">https://www.cis.upenn.edu/~stevez/papers/MZZ10.pdf</a></li>
<li><a href="https://github.com/EduardoRFS/linear-f" target="_blank" rel="noopener">https://github.com/EduardoRFS/linear-f</a></li>
<li><a href="https://oleg.fi/gists/posts/2019-06-26-linear-church-encodings.html" target="_blank" rel="noopener">https://oleg.fi/gists/posts/2019-06-26-linear-church-encodings.html</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://eduardorfs.github.io/2023/01/08/weakening_on_linear_f/" data-id="clcnpdstf0004jusb7yv8xwgf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linear/">linear</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ocaml/">ocaml</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/theory/">theory</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/typer/">typer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-a_different_level_based_typer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/09/26/a_different_level_based_typer/" class="article-date">
  <time datetime="2021-09-26T22:34:35.000Z" itemprop="datePublished">2021-09-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/09/26/a_different_level_based_typer/">A different level based typer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>In this post I will try to propose / share a rank / level based typer which I believe has free generalization, it can be adapted to the core typer present at OCaml(let-ranking) and SML(lambda-ranking) while still following the same mental model.</p>
<p><strong>warning, no soundness guarantees</strong></p>
<h2 id="TLDR"><a href="#TLDR" class="headerlink" title="TLDR"></a>TLDR</h2><p>We can make so that the level on a rank / level based typer always only increases and couple the dead region to the generalized region so that generalization is free. That requires an additional pass that can be done together with parsing for a “true” “free” generalization.</p>
<h2 id="How-did-I-get-here"><a href="#How-did-I-get-here" class="headerlink" title="How did I get here"></a>How did I get here</h2><p>Recently I’ve been studying how types and typers works, that includes classical like STLC(Simple Typed Lambda Calculus), HM (Damas-Hindley-Milner type system), System F.</p>
<p>And around the way I implemented many typers and start to understand how they work in theory and in practice(value restriction), most of them implemented in OCaml and as a natural thing I started to look more and more in the OCaml typer which I already had some intuitive understanding after so many <code>type constructor t would escape it&#39;s scope</code>.</p>
<p>But after reading <a href="http://okmij.org/ftp/ML/generalization.html" target="_blank" rel="noopener">How OCaml type checker work</a> by Oleg I had an enlightenment on the topic, but there is a hard feeling on me of “this can be extended even further”, so I tried the natural ideas that came to my mind, using negative levels to encode multiple forall levels and short circuit instantiation, which seems promising and I plan to make a post in the following weeks, the other one is levels that always increase which is the topic of this week.</p>
<p><strong>I HIGHLY RECOMMEND</strong> that you read <a href="http://okmij.org/ftp/ML/generalization.html" target="_blank" rel="noopener">How OCaml type checker work</a> to understand what I’m talking about and find any problem in my approach.</p>
<h2 id="What-is-a-level-based-typer"><a href="#What-is-a-level-based-typer" class="headerlink" title="What is a level based typer?"></a>What is a level based typer?</h2><p>The idea is that we’re using instead of scanning the context during typing we’re gonna use a level to know when a type variable is present in the scope then generalize it, this is effectivelly an algorithm of escape analysis. It was invented / discovered by Didier Rémy and it leads to a more efficient implementation of a HM typer.</p>
<p>Note that Didier Rémy and the literature calls levels, ranks, but the OCaml typer calls it levels, and it makes more sense in my head(probably bias), so I will be using levels here.</p>
<p>It is <a href="http://people.cs.uchicago.edu/~gkuan/pubs/ml07-km.pdf" target="_blank" rel="noopener">formalized to be equivalent to the Algorithm W</a> which ensures that it generates the most general type and in a sound manner.</p>
<p>It also exists in two major variations:</p>
<ul>
<li>lambda-ranking, every lambda introduces a new level and generalizes</li>
<li>let-ranking, every let introduces a new level and generalizes.<br>Each has it’s advantages and the idea showed here can easily work with both, but my implementation will focus more on lambda-ranking as for me it looks that it it can be more easily extended.</li>
</ul>
<h2 id="Generalization"><a href="#Generalization" class="headerlink" title="Generalization"></a>Generalization</h2><p>One of the properties of this family of typers is that generalization requires you to go over the type after typing some expression to check if it is bigger than the current level and mark it as quantified, as a level bigger than the current level lives in a dead region and never escaped it’s region, so it’s not present in the context, again escape analysis.</p>
<p>While this is cheap as types are treated as always being really small, it’s not free and will do O(n) operations being n the number of nodes in the type tree.</p>
<h2 id="The-dead-region"><a href="#The-dead-region" class="headerlink" title="The dead region"></a>The dead region</h2><p>A dead region is a region of code that was already typed and lies “above” the current typing point.</p>
<p>In the current designs all type variables in a dead region are treated as quantified because we know that they never escaped it’s scope. And so they need to actually be elevated to a level where all variables are quantified, essentially it’s a process where we look on a type and check if it’s in a dead region, if so mark it.</p>
<p>Here I will be proposing that the dead region should be the quantified level and that any variable at the dead region.</p>
<p>So any variable outside of the dead region should be treated as a free variable and not duplicated during instantiation, any variable inside the dead region is a quantified variable and should be duplicated during instantiation</p>
<h2 id="Moving-the-line-in-only-one-direction"><a href="#Moving-the-line-in-only-one-direction" class="headerlink" title="Moving the line in only one direction"></a>Moving the line in only one direction</h2><p>Because the dead region moves as typing is done and now the level that marks something to be quantified is the same as the level that delimits the dead region. So my proposal is essentially that the level that marks what is quantified is actually moving.</p>
<p>You can imagine that the level that marks something as generalized is a line where everything below it, is not generalized and everything above it is generalized, currently we’re moving every type that is not on the generalized level individually to above the line, here we will be actually moving the line so that all types which did not escape its scope are automatically treated as quantified. This makes so that generalization is now an O(1) operation, and effectivelly incrementing an integer.</p>
<h2 id="Creating-variables-in-the-future"><a href="#Creating-variables-in-the-future" class="headerlink" title="Creating variables in the future"></a>Creating variables in the future</h2><p>But this means that creating a variable on the current level doesn’t work as a free variable for it’s inner expressions, a solution to this is creating a variable in the level after the current typing finishes.</p>
<p>This doesn’t work with the way that we normally do regions by entering and leaving a region, as the level after typing everything will always be the same level as before typing everything, so instead of entering and leaving, we only enters a region and never leaves it.</p>
<p>But this means that before typing the typer needs to somehow know what will be the region after it finishes it’s typing, this means that we need to somehow know the future.</p>
<p>A simple solution is to do a pass annotating every AST node that create a variable, with the level expected after typing its content, this pass can actually happens for “free” by doing it during parsing so that there is no cost of iterating the AST.</p>
<p>In lambda-ranking this means that lambda + application will need to carry an additional level in the AST. In let-ranking only a let is required to carry the additional level.</p>
<h2 id="Moving-the-line"><a href="#Moving-the-line" class="headerlink" title="Moving the line"></a>Moving the line</h2><p>So during typing of an expression variables are created on the type after the current expressions finishes and after every expression the level is increased, marking that we leaved the current region.</p>
<p>This also requires that when unifying two types instead of the end type being always the smallest possible type it will be the largest possible type, so that unifying <code>&#39;a[1] : &#39;b[2]</code> will results in <code>&#39;b[2]</code>.</p>
<h2 id="Value-Restriction"><a href="#Value-Restriction" class="headerlink" title="Value Restriction?"></a>Value Restriction?</h2><p>Yeah, I don’t know. But I believe the easiest way is to tag types with some crazy big level.</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>The following implementation does lambda-ranking + free generalization as described above, while I’m not so sure the current implementation is sound, I’m hoping the idea described here is.</p>
<p><a href="https://github.com/EduardoRFS/eduardorfs.github.io/blob/gh-pages/code/a_different_level_based_typer.ml" target="_blank" rel="noopener">a_different_level_based_typer.ml</a></p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="http://okmij.org/ftp/ML/generalization.html" target="_blank" rel="noopener">http://okmij.org/ftp/ML/generalization.html</a></li>
<li><a href="http://people.cs.uchicago.edu/~gkuan/pubs/ml07-km.pdf" target="_blank" rel="noopener">http://people.cs.uchicago.edu/~gkuan/pubs/ml07-km.pdf</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://eduardorfs.github.io/2021/09/26/a_different_level_based_typer/" data-id="clcnpdst70000jusbfaa8votj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ocaml/">ocaml</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/theory/">theory</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/typer/">typer</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-journey_into_reason_mobile" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/19/journey_into_reason_mobile/" class="article-date">
  <time datetime="2020-08-19T08:10:17.000Z" itemprop="datePublished">2020-08-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/19/journey_into_reason_mobile/">A journey into Reason Mobile</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This is mostly a report on why simple things aren’t simple so no TLDR. And also a bit about Reason Mobile.</p>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>Last year(2019) when I was still employed I was looking at a cool piece of tech, called <code>Revery</code> a framework to develop desktop applications using Reason Native, JSX and super fast, also it’s not React, it felt really cool, trying some applications like Oni2 the performance was really impressive.</p>
<p>At this time I was still employed and was working with embedded, on a device with 128mb of memory, running on a armv7hf linux box with a broken userspace running QT and using QML, a screen that could only make full updates 5 times per second, yes 5fps. Then I was really curious would it be possible to use something like Revery to make embedded development? Sure this thing can run Revery right?</p>
<p>I was correct(I always am)</p>
<h2 id="But-…-OCaml"><a href="#But-…-OCaml" class="headerlink" title="But … OCaml"></a>But … OCaml</h2><p>Normally I would say that a cool feature of Reason is being fully compatible with OCaml, so that you can easily use the tools from the OCaml ecosystem like the compiler, build system’s like <code>Dune</code> and even packages from <code>opam</code> to build native applications aka Reason Native.</p>
<p>This time was a little bit different, see, using the OCaml ecosystem also makes Reason Native suffer from the same problems as the OCaml ecosystem, like missing proper tooling to cross compile and not having a great support for Android and iOS.</p>
<p>Yeah the hardware could easily run it, it’s possible to run Revery with less than 64mb of memory and a potato as a CPU, it will not be exactly efficient on battery but that was okay for me, but the tooling? There was no tooling</p>
<p>To make things worse, we also have a new tool, called <code>esy</code> which can consume opam and npm packages, while also making a really easy to reproduce environment, is a really cool piece of tech, but how does it works? Yeah sandboxing, and that completely break the previous attempts to cross compile from the OCaml ecosystem namely <code>opam-cross</code>.</p>
<h2 id="The-easy-trick"><a href="#The-easy-trick" class="headerlink" title="The easy trick"></a>The easy trick</h2><p>The obvious choice is “caveman cross-compiling” just emulate the entire environment, sure, it did work, took a couple of hours and I got to compile binaries from Linux x86_64 to Linux ARMv7l, there is just a single detail, the reason why it took a couple of hours isn’t because the setup of the environment needed any trick, nope, with esy that “just works”, it took a couple hours because emulating an ISA is one of the slowest thing you can ever do if you’re doing it properly and especially emulating a RISC on a CISC like ARMv7l on x86_64.</p>
<p>But the trick that I was doing is called full system emulation, there is also another trick which uses user-space emulation combined with binfmt to run a chroot(like a docker container) from one architecture in the other. That was a lot better, but probably still 5x slower than natively compiling on my desktop.</p>
<h2 id="Hackish-Solution"><a href="#Hackish-Solution" class="headerlink" title="Hackish Solution"></a>Hackish Solution</h2><p>A couple of months ago, I was not employed anymore and had a lot of spare time, so I tried to properly address that by adding cross compiling support on <code>esy</code>, yeah that wasn’t so simple, modeling multiple versions of the same package turned out to be really tricky, and I didn’t have any proper knowledge on package managers, then I made a hackish solution, like really hackish, I don’t even want to tell you how it works, but trust me it’s a hackish solution.</p>
<p>I called it <a href="https://github.com/EduardoRFS/reason-mobile" target="_blank" rel="noopener">reason-mobile</a> a bad name, but the intent was “providing tools to cross compile Reason to mobile aka Android and iOS”, on that … yeah I got it to work.</p>
<p>This entire time I was only looking on Android, because it’s what I daily drive … no iOS wasn’t simpler. But well what you need to know now is that it works, in a <code>future post</code> the road to iOS can be discussed. Currently it works.</p>
<h2 id="How-to-use-it"><a href="#How-to-use-it" class="headerlink" title="How to use it?"></a>How to use it?</h2><p>It’s a hackish solution, you clone the repository, <strong>put your project inside the root of the project</strong>, and run some magic, there is a example on the README, but the commented script is the following</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:EduardoRFS/reason-mobile.git</span><br><span class="line"><span class="built_in">cd</span> reason-mobile/hello-reason</span><br><span class="line"></span><br><span class="line"><span class="comment">## it will install the host dependencies</span></span><br><span class="line">esy install</span><br><span class="line"></span><br><span class="line"><span class="comment">## cursed node magic, don't ask</span></span><br><span class="line">node ../generate/dist/cli.js android.arm64</span><br><span class="line"></span><br><span class="line"><span class="comment">## builds all the dependencies for host and target</span></span><br><span class="line"><span class="comment">## it's going to take a while, seriously</span></span><br><span class="line">esy @android.arm64</span><br><span class="line"></span><br><span class="line"><span class="comment">## enter the patched esy shell</span></span><br><span class="line">esy @android.arm64 not-esy-setup <span class="variable">$SHELL</span></span><br></pre></td></tr></table></figure>

<p>Inside this shell you can run the normal commands, like</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## it will build for Android ARM64</span></span><br><span class="line">dune build -x android.arm64</span><br><span class="line"></span><br><span class="line"><span class="comment">## binary located at</span></span><br><span class="line">ls -lah <span class="variable">$cur__target_dir</span>/default.android.arm64/bin/hello.exe</span><br></pre></td></tr></table></figure>

<h2 id="Supported-platforms"><a href="#Supported-platforms" class="headerlink" title="Supported platforms"></a>Supported platforms</h2><ul>
<li>android.arm64</li>
<li>android.x86_64</li>
<li>ios.arm64</li>
<li>ios.simulator.x86_64</li>
<li>linux.musl.x86_64</li>
</ul>
<h2 id="Ok-so-how-it-works"><a href="#Ok-so-how-it-works" class="headerlink" title="Ok, so how it works?"></a>Ok, so how it works?</h2><p>Mostly bad magic, and a lot of shell script hacked.</p>
<p>Reads the <code>esy.lock</code> generated by <code>esy</code>, extract a lot of data using some low level commands from esy like <code>esy ls-build</code> and <code>esy build-plan</code>, duplicate every dependency adding a prefix to it, patch commands like <code>dune build</code>, add some hand made patches for broken dependencies, add a shell script wrapper to remove <code>OCAMLLIB</code> and <code>OCAMLPATH</code> from the environment as these’s are problematic with cross compilation.</p>
<p>Then it generate a bunch of files inside <code>.mocks</code> and a “package.json” for the specific platform, so you can do <code>esy @android.arm64</code>, but that would still make your environment be broken so it has another hack, <code>esy @android.arm64 not-esy-setup &lt;command&gt;</code> which will execute commands in the patched environment.</p>
<p>Simple as that</p>
<h2 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h2><p>I tried all supported platforms from Linux and Mac, I have no idea if it works on Windows, my bet is that it will not even on cygwin but feel free to try.</p>
<p>And there will be some bugs, if you need help with it feel free to contact me.</p>
<h2 id="Future-and-possibilities"><a href="#Future-and-possibilities" class="headerlink" title="Future and possibilities"></a>Future and possibilities</h2><p>I started talking about Revery, yeah that was also maded and is <code>another post</code></p>
<p>We also need a proper solution, integrated on <code>esy</code>, ideally doing a lot of magic.</p>
<p>Maybe Reason React Native Native? You know, RRNN, maybe RNRN, it need’s a better name, but it’s also something that I’m looking for.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://eduardorfs.github.io/2020/08/19/journey_into_reason_mobile/" data-id="clcnpdste0003jusbkp5ti6pl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cross-compile/">cross-compile</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mobile/">mobile</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/native/">native</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ocaml/">ocaml</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/reason/">reason</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/cross-compile/">cross-compile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linear/">linear</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mobile/">mobile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/native/">native</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ocaml/">ocaml</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reason/">reason</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/theory/">theory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typer/">typer</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/cross-compile/" style="font-size: 10px;">cross-compile</a> <a href="/tags/linear/" style="font-size: 10px;">linear</a> <a href="/tags/mobile/" style="font-size: 10px;">mobile</a> <a href="/tags/native/" style="font-size: 10px;">native</a> <a href="/tags/ocaml/" style="font-size: 20px;">ocaml</a> <a href="/tags/reason/" style="font-size: 10px;">reason</a> <a href="/tags/theory/" style="font-size: 15px;">theory</a> <a href="/tags/typer/" style="font-size: 15px;">typer</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/08/weakening_on_linear_f/">A tale of sum types on Linear F</a>
          </li>
        
          <li>
            <a href="/2021/09/26/a_different_level_based_typer/">A different level based typer</a>
          </li>
        
          <li>
            <a href="/2020/08/19/journey_into_reason_mobile/">A journey into Reason Mobile</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <!-- <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Eduardo Rafael<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer> -->

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav> -->
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>